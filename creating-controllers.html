<!doctype html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Creating Controllers</title>
    <link rel="stylesheet" href="/ProvisionerDocs/lib/bootstrap/dist/css/bootstrap-darkly.css?linkver=20210601014743" type="text/css">

</head>

<body>

    <nav class="navbar navbar-dark bg-dark" data-hr-run="edity.theme.layouts.default">
        <button class="navbar-toggler" type="button" data-target="#sidebar" data-toggle="sidebar" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <a class="navbar-brand" href="/ProvisionerDocs/">Threax Provisioner</a>
    </nav>

    <div id="wrapper">
        <!-- Sidebar -->
        <div id="sidebar">
            <div class="mainTreeMenu" data-hr-controller="treeMenu" data-hr-config-urlroot="/ProvisionerDocs/" data-hr-config-menu="/ProvisionerDocs/menus/mainMenu.json" data-hr-config-scrollelement="#sidebar-wrapper" data-hr-model-component="sidebarMenuComponent" data-hr-config-treemenu-version="AEB2589166B5AEA08E50455AC55B0DCF1ACD5B51D9220E83A1BB73D030016367">
                <ul class="sidebarMenu" data-hr-model="childItems" data-hr-model-component="sidebarMenuComponent">
                    <template data-hr-component="sidebarMenuComponent">
                        <li class="folder">
                            <div class="item" data-hr-on-click="toggleMenuItem" data-hr-toggle="current" data-hr-class-on="currentFolder"><span data-hr-toggle="children" class="glyphicon" data-hr-class-on="glyphicon-folder-open" data-hr-class-off="glyphicon-folder-close"></span> {{name}}</div>
                            <div class="children" data-hr-model="children" data-hr-model-component="sidebarMenuComponent" data-hr-toggle="children" data-hr-class-on="expanded" data-hr-style-off="display:none;"></div>
                        </li>
                    </template>
                    <template data-hr-variant="link">
                        <li class="link">
                            <a href="{{urlRoot}}{{link}}" target="{{target}}">
                                <div class="mainBlock" data-hr-toggle="current" data-hr-class-on="currentLink">
                                    {{name}}
                                </div>
                            </a>
                        </li>
                    </template>
                    <template data-hr-variant="root">
                        <div class="children" data-hr-model="children" data-hr-model-component="sidebarMenuComponent" data-hr-toggle="children" data-hr-class-on="expanded" data-hr-style-off="display:none;"></div>
                    </template>
                </ul>
            </div>
        </div>

        <!-- Page Content -->
        <div id="content">
            <div class="container-fluid">
                <div class="row">
                    <div class="col-md-12 pageContent">
                        <h1>Creating Controllers</h1>
<p>Now that we have a standard way to talk to other applications we need to write the code that does the actual work. This takes the form of a controller class with a Run function on it. That Run function can optionally take the top level configuration class instance. The controllers separate the per app configuration from the classes that are injected to do work. This way they can be reused to do more work later. Ideally they will have no state at all to make it possible to use them in parallel, but this isn&#39;t always possible. There aren&#39;t too many rules for controllers. If you keep them small and composable you will be able to test them more easily in small pieces, but you can still create other controllers that do several pieces of work. The reference implementation can do a full provision and deployment using a single command on a set of files. This is built out of the other smaller controllers.</p>
<h2>Parallelism and State</h2>
<p>Ideally controllers are carefully written so they can be used from multiple threads simultaneously. This is not as hard as it seems. Any other controllers or services the current controller needs should be added as read only and not modified, which the complier will enforce. Any state that the current controller needs can be put into a Lazy&lt;Task&lt;T&gt;&gt; that will do the common work an return it. For example the <a href="https://github.com/threax/Threax.Provision.Azure/blob/master/Threax.AzureVmProvisioner/Services/SshCredsManager.cs">SshCredentialManager</a> class in the reference implementation works this way. It loads the external info it needs in the Lazy and returns a task. This will only happen once and all other threads will get the task back directly from the lazy. If the work is completed the result is available right away. Otherwise the thread will block until the work is complete.</p>
<p>If you can&#39;t fit your state into the lazy task pattern take advantage of .Net&#39;s SemaphoreSlim class. The <a href="https://github.com/threax/Threax.Provision.Azure/blob/master/Threax.AzureVmProvisioner/Controller/FullDeploy.cs">FullDeploy</a> controller shows how this works. Create a SemaphoreSlim that allows 1 item in. Next use WaitAsync and Release to get access to the semaphore, do the shared work and then release.</p>
<h2>Gaining Parallelism</h2>
<p>However, on their own these things will not add any parallel computation. To get this use the async and await keywords. All the controllers are already async tasks, which sets them up to await and main is an async main. What this will do is give us one primary thread that will run until it hits an await where the work is being done in another thread. It will then stop execution of the current task and if there are other tasks waiting it will start executing them. However, on its own just adding async and await everywhere won&#39;t really do much. You have to start running multiple things. Consider the Create controller:</p>
<p><code>public async Task Run(Configuration config)
	<br>{
	<br>&nbsp;&nbsp;&nbsp; logger.LogInformation(&quot;Creating app resources.&quot;);</code></p>
<p><code>&nbsp;&nbsp;&nbsp; await runInfoLogger.Log(config);
	<br>&nbsp;&nbsp;&nbsp; await CreateAppVault.Run(config);
	<br>&nbsp;&nbsp;&nbsp; await Task.WhenAll
	<br>&nbsp;&nbsp;&nbsp; (
	<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CreateApp.Run(config),
	<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CreateAppSqlDatabase.Run(config),
	<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CreateAppStorage.Run(config),
	<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CreateAppCertificate.Run(config),
	<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LoadExternalSecrets.Run(config)
	<br>&nbsp;&nbsp;&nbsp; );
	<br>}</code></p>
<p>Here the app vault will have to be created before we do the other steps. However, all the other steps, making the vm, creating the sql db etc are setup to run in parallel. There is still only one thread actually running these tasks so all the processing for each of these steps will happen on the main thread, but each point where they await could potentially give up processing time for something else. This is useful since a provisioner spends most of its time waiting on something else to complete and a great deal of things that are done can be done at the same time.</p>
<h2>Controlling External App Parallelsim</h2>
<p>If you notice in the provisioner code there are no calls to Thread.Start, which is the only thing that can make us actually give up our timeslice. That is because it is happening inside the Threax.ProcessHelper library when you use the async functions to call external commands. If you don&#39;t use the async verisons the main provisioner thread will stop and wait for the external process to complete. This is very powerful if that external process is not safe to run multiple times at once. If you know a command is safe to call multiple times at once call the async version with await. If you know the command should only run one at a time use the non-async version, which will force the provisioner to stop all other processing until that task is complete. This slows it down, but sometimes you need the safety. Of course you have to ensure only one provisioner is running at a time, but that is a separate issue.</p>
                        <div class="footer"></div>
                    </div>
                </div>
                <div class="footer-padding"></div>
            </div>
        </div>
    </div>
    <script type="text/javascript" src="/ProvisionerDocs/lib/tslib.js?linkver=20210601014743"></script>
<script type="text/javascript" src="/ProvisionerDocs/lib/jquery/dist/jquery.min.js?linkver=20210601014743"></script>
<script type="text/javascript" src="/ProvisionerDocs/lib/popper.js/dist/popper.min.js?linkver=20210601014743"></script>
<script type="text/javascript" src="/ProvisionerDocs/lib/bootstrap/dist/js/bootstrap.min.js?linkver=20210601014743"></script>
<script type="text/javascript" src="/ProvisionerDocs/lib/tsbin.prod.js?linkver=20210601014743"></script>
<script type="text/javascript" src="/ProvisionerDocs/lib/hr-run.js?linkver=20210601014743"></script>

</body>

</html>