<h1>Parallelism and State</h1>
<p>Ideally controllers and services are carefully written so they can be used from multiple threads simultaneously. This can make the code more complicated, but following a few rules should take care of the issues that crop up. Any dependencies that are needed should be added as read only and not modified, which the complier will enforce. Any state that needs to be loaded externally can be put into a Lazy&lt;Task&lt;T&gt;&gt; that will do the common work an return it. For example the <a href="https://github.com/threax/Threax.Provision.Azure/blob/master/Threax.AzureVmProvisioner/Services/SshCredsManager.cs">SshCredentialManager</a> class in the reference implementation works this way. It loads the external info it needs in the Lazy and returns a task. This will only happen once and all other threads will get the task back directly from the lazy. If the work is completed the result is available right away. Otherwise the thread will block until the work is complete. Finally, if you can&#39;t fit your state into the lazy task pattern take advantage of .Net&#39;s SemaphoreSlim class. The <a href="https://github.com/threax/Threax.Provision.Azure/blob/master/Threax.AzureVmProvisioner/Controller/FullDeploy.cs">FullDeploy</a> controller shows how this works. Create a SemaphoreSlim that allows 1 item in. Next use WaitAsync and Release to get access to the semaphore, do the shared work and then release.</p>
<h2>Gaining Parallelism</h2>
<p>However, on their own these things will not add any parallel computation. To get this use the async and await keywords. All the controllers are already async tasks, which sets them up to await and main is an async main. What this will do is give us one primary thread that will run until it hits an await where the work is being done in another thread. It will then stop execution of the current task and if there are other tasks waiting it will start executing them. However, on its own just adding async and await everywhere won&#39;t really do much. You have to start running multiple things. Consider the Create controller:</p>
<p><code>public async Task Run(Configuration config)
	<br />{
	<br />&nbsp;&nbsp;&nbsp; logger.LogInformation(&quot;Creating app resources.&quot;);</code></p>
<p><code>&nbsp;&nbsp;&nbsp; await runInfoLogger.Log(config);
	<br />&nbsp;&nbsp;&nbsp; await CreateAppVault.Run(config);
	<br />&nbsp;&nbsp;&nbsp; await Task.WhenAll
	<br />&nbsp;&nbsp;&nbsp; (
	<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CreateApp.Run(config),
	<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CreateAppSqlDatabase.Run(config),
	<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CreateAppStorage.Run(config),
	<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CreateAppCertificate.Run(config),
	<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LoadExternalSecrets.Run(config)
	<br />&nbsp;&nbsp;&nbsp; );
	<br />}</code></p>
<p>Here the app vault will have to be created before we do the other steps. However, all the other steps, making the vm, creating the sql db etc are setup to run in parallel. There is still only one thread actually running these tasks so all the processing for each of these steps will happen on the main thread, but each point where they await could potentially give up processing time for something else. This is useful since a provisioner spends most of its time waiting on something else to complete and a great deal of things that are done can be done at the same time.</p>
<h2>Controlling External App Parallelsim</h2>
<p>If you notice in the provisioner code there are no calls to Thread.Start or Task.Run, which are the only things that can make us actually give up our timeslice. That is because it is happening inside the Threax.ProcessHelper library when you use the async functions to call external commands. If you don&#39;t use the async verisons the main provisioner thread will stop and wait for the external process to complete. This is very powerful if that external process is not safe to run multiple times at once. If you know a command is safe to call multiple times at once call the async version with await. If you know the command should only run one at a time use the non-async version, which will force the provisioner to stop all other processing until that task is complete. This slows it down, but sometimes you need the safety. Of course you have to ensure only one provisioner is running at a time, but that is a separate issue.</p>